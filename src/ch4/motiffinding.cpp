#include "problems.h"

/**
 * GenerateMotifSequences - Create a list of N random ACTG sequences of length L with a random motif of
 * length K <= L with the motif randomly embedded at different locations in the generated sequences.
 *
 * @param  nSeq     [in]            Number of sequences to generate.
 * @param  seqLen   [in]            Length of the generated sequences.
 * @param  motifLen [in]            Length of motif to embed.
 * @param  seqs     [in/out]        List of sequences to populate in this function.
 * @param  motif    [in/out]        Motif generated by this function.
 * @param  offsets  [description]   Offset of motif in each generated sequence.
 *
 * @return           INVALID_INPUT if motif length greater than sequence length. Otherwise OK after sequences generated.
 */

static ResultCode GenerateMotifSequences(
    const uint32_t nSeq,
    const uint32_t seqLen,
    const uint32_t motifLen,
    vector<string>& seqs,
    string& motif,
    vector<uint32_t> &offsets
)
{
    if (motifLen > seqLen) return INVALID_INPUT;

    const char bases[4] = { 'A', 'C', 'T', 'G' };
    
    for (uint32_t i = 0; i < motifLen; i++) motif += bases[rand() % 4];

    const uint32_t offsetRange = seqLen - motifLen;

    for (uint32_t i = 0; i < nSeq; i++)
    {
        string curSeq = "";
        for (uint32_t j = 0; j < seqLen; j++) curSeq += bases[rand() % 4];

        offsets.push_back(rand() % offsetRange);
        memcpy(&curSeq[0] + offsets[i], &motif[0], motifLen);
        seqs.push_back(curSeq);
    }

    return OK;
}

struct SearchNode
{
    uint32_t offsetVal;
    uint32_t prefixScore;
    vector<bool> childOffsetSearched;
    
    SearchNode(uint32_t curOFfset, uint32_t numChildren) : prefixScore(0), offsetVal(curOFfset) 
    { 
        childOffsetSearched.resize(numChildren, false); 
    }
};

/**
 * GetConsensus - Given a list of sequences, a motif length K to search for, and offsets into input
 * sequences, compute a "consensus" score. For each index 0 <= n <= k, count the occurrences
 * of A/C/T/G across the sequences at their input offsets. Whichever base has the highest count, add its count
 * to the total score. Sum across motif length. A prefix length P can be used to score from the first P offsets. 
 * This can be used to compute a bound on the highest possible score for all remaining offsets, which can be used
 * to rule certain search branches.
 *
 * High scores mean highly similar substrings for the current offsets, 
 * low scores mean disimilar substrings.
 *
 * @param  seqs         [in] List of sequences to search for motif.
 * @param  prefixLen    [in] How many of the input sequences to use for scoring if checking a prefix.
 * @param  offsets      [in] Offset into each sequence for consensus score computation.
 * @param  motifLen     [in] Length of the motif we're searching for.
 *
 * @return              Consensus score at current offsets.
 */

uint32_t GetConsensus(
    const vector<string>& seqs,
    const uint32_t prefixLen,
    const vector<uint32_t>& offsets,
    const uint32_t motifLen
)
{
    vector<uint32_t> aScore(motifLen, 0);
    vector<uint32_t> tScore(motifLen, 0);
    vector<uint32_t> cScore(motifLen, 0);
    vector<uint32_t> gScore(motifLen, 0);

    uint32_t consensus = 0;

    for (uint32_t i = 0; i < prefixLen; i++)
    {
        for (uint32_t j = 0; j < motifLen; j++)
        {
            char base = seqs[i][offsets[i] + j];

            switch (base)
            {
            case 'A':

                aScore[j]++;
                break;

            case 'T':

                tScore[j]++;
                break;

            case 'C':

                cScore[j]++;
                break;

            case 'G':

                gScore[j]++;
                break;

            default:
                break;
            }
        }
    }

    for (uint32_t i = 0; i < motifLen; i++)
    {
        uint32_t best = aScore[i];
        if (tScore[i] > best) best = tScore[i];
        if (cScore[i] > best) best = cScore[i];
        if (gScore[i] > best) best = gScore[i];

        consensus += best;
    }

    return consensus;
}

/**
 * FindMotif - Search for a motif (common substring) of length K in a list of sequences of length L >= K.
 *
 * @param  seqs     [in]    Sequences to search for a motif.
 * @param  motifLen [in]    Length of desired motif.
 * @param  offsets  [out]   A set of offsets into each input sequence that produces the best motif match.
 *
 * @return          INVALID_INPUT of desired motif length greater than input sequence lengths. OK otherwise.
 */

ResultCode FindMotif(const vector<string>& seqs, const uint32_t motifLen, vector<uint32_t>& offsets)
{
    if (motifLen > seqs[0].length()) return INVALID_INPUT;

    vector<SearchNode> stack;

    const uint32_t seqLen       = seqs[0].length();
    const uint32_t offsetRange  = seqLen - motifLen;

    offsets.resize(seqs.size(), 0);
    uint32_t bestScore = 0;

    for (uint32_t i = 0; i < seqLen; i++)
    {
        stack.push_back(SearchNode(i, offsetRange));

        while (!stack.empty())
        {
            // We searched down into a leaf. Get its consensus score.

            if (stack.size() == seqs.size())
            {
                vector<uint32_t> curOffsets(seqs.size(), 0);
                for (uint32_t j = 0; j < stack.size(); j++) curOffsets[j] = stack[j].offsetVal;
                uint32_t curScore = GetConsensus(seqs, seqs.size(), curOffsets, motifLen);

                if (curScore > bestScore)
                {
                    bestScore = curScore;
                    memcpy(&offsets[0], &curOffsets[0], seqs.size() * sizeof(uint32_t));
                }

                stack.pop_back();
                continue;
            }

            auto& cur = stack.back();

            // Not at a leaf. Check its prefix score. If prefixScore + best possible child score < current
            // best consensus, no need to continue searching this branch.

            if (cur.prefixScore == 0)
            {
                vector<uint32_t> curOffsets(stack.size(), 0);
                for (uint32_t j = 0; j < stack.size(); j++) curOffsets[j] = stack[j].offsetVal;
                cur.prefixScore = GetConsensus(seqs, stack.size(), curOffsets, motifLen);
            }

            uint32_t childScoreBound = (seqs.size() - stack.size()) * motifLen;

            if (cur.prefixScore + childScoreBound > bestScore)
            {
                bool allChildrenSearched = true;

                for (uint32_t j = 0; j < cur.childOffsetSearched.size(); j++)
                {
                    if (!cur.childOffsetSearched[j])
                    {
                        cur.childOffsetSearched[j] = true;
                        stack.push_back(SearchNode(j, offsetRange));
                        allChildrenSearched = false;
                        break;
                    }
                }

                if (allChildrenSearched) stack.pop_back();
            }
            else
                stack.pop_back();
        }
    }

    return OK;
}

/**
 * [MotifFinding description]
 * @param testResults [description]
 */

void MotifFinding(vector<TestResult>& testResults)
{
    const uint32_t nSeq     = 10;
    const uint32_t seqLen   = 100;
    const uint32_t motifLen = 6;

    vector<string> seq;
    string motif;
    vector<uint32_t> offsets;

    GenerateMotifSequences(nSeq, seqLen, motifLen, seq, motif, offsets);

    vector<uint32_t> resultOffsets;

    FindMotif(seq, motifLen, resultOffsets);

    __debugbreak();
}